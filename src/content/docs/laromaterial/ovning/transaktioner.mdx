---
title: "Övning: Transaktioner i databas" 
description: "Övning för att använda transaktioner i en databas."
author: mos
revision:
    "2026-02-06": "(A, mos) Första versionen utifrån en befintlig artikel https://dbwebb.se/kunskap/transaktioner-i-databas."
sidebar:
    order: 0400
---

import Figure from '@components/CustomFigure.astro';
import YouTube from '@components/YouTube.astro';

{/*
TODO
* 
* 
*/}

En transaktion i en databas omsluter flera händelser och gör dem atomära -- antingen utförs samtliga händelser, eller ingen.

För att ta ett exempel där man vill flytta pengar från en ägare till en annan och informationen om detta finns i en databas. Först plockar man bort pengen från den ena och sedan lägger man till pengen till den andre. Flytten som består av två SQL-satser måste utföras i sin helhet, eller inte alls. Här kommer en transaktion till hjälp. Transaktionen kan garantera att båda SQL-satserna utförs i sin helhet, eller ingen alls.

{/*
import cs1 from '@assets/databas/csharp/cs1.png';

<Figure 
    src={cs1}
    caption="Ett C# program som presenterar data från databasen classicmodels."
/>
*/}



## Förutsättningar

Exemplet visar hur du jobbar med transaktioner i MariaDB. 

Du kan läsa om [transaktioner i manualen för MariaDB](https://mariadb.com/kb/en/transactions/).



## Inspelad föreläsning

Det finns en inspelad föreläsning "[Transaktioner i databaser - ACID](/website/laromaterial/forelasning/transaktioner/)" som berör samma ämne som denna artikel hanterar. Du kan välja att titta på den för att komplettera den bilden du får från artikeln, eller som en introduktion till ämnet, innan du börjar jobba med artikeln.



## ACID

ACID är en samling properties för databastransaktioner. De beskriver hur en transaktion måste bete sig.

| Property        | Beskrivning |
|-----------------|-------------|
| A - Atomicity   | En transaktion utförs som en enhet, eller inte alls, allt eller inget. Den är odelbar. |
| C - Consistency | Transaktionen flyttar databasen från ett giltigt läge till ett annat och alla regler såsom *constraints*, *cascades* och triggers skall vara giltiga. |
| I - Isolation   | Även om flera transaktioner exekveras samtidigt så skall resultatet från transaktionerna betraktas som om de exekverades sekventiellt. En transaktion kan inte se effekter av en delvis exekverad transaktion. |
| D - Durability  | När en transaktion är *committad* så skall den vara beständig, även om strömmen går och databasmotorn krashar. |

En transaktion skall alltså vara atomär (A), bevara konsistensen (C) i databasen, vara isolerad (I) från övriga transaktioner och vara beständig (D) när den är committad. Därav ACID.

En transaktion innebär att en eller flera SQL-satser utförs i sin helhet, eller inte alls.



## Spara ditt arbete i ditt kursrepo

I ditt kursrepo, skapa följande katalog där du kan spara ditt arbete med denna övning:

```bash title="Skapa katalog för övningen"
# Gå till ditt kursrepo
cd kmom/04

# Skapa en katalog
mkdir transaction
cd transaction

# Öppna katalogen i VS Code
code .
```

Skapa filen `create.sql` och lägg in följande kommentar, överst i filen.

```sql title="create.sql"
-- Example code on how to work with transactions.
-- Course: databas
-- Author: Your Name
-- Date: ÅÅÅÅ-MM-DD
```

Uppdatera med rätt datum och namn. 



## En testdatabas

I artikeln behöver du en databas och tabeller. Du behöver skriva SQL-kod för att skapa dessa. Börja med att skapa en databas, spara koden du skriver i `create.sql` och försäkra dig alltid om att du kan köra all kod i `create.sql` som ett SQL-script.

Börja med att skapa en databas som du döper till "mydb".

```sql title="Create the mydb database"
DROP DATABASE IF EXISTS `mydb`;
CREATE DATABASE `mydb`
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_unicode_ci
;

USE `mydb`;
```

Verifiera att du kan köra ditt skript en gång och därefter en gång till. Sedan vet du att skriptet fungerar.



## En tabell

Låt oss bygga en bitcoin bank där Adam och Eva skall flytta en mängd bitcoins mellan varandra.

Vi behöver först skapa en tabell där de lagrar sina bitcoins.

Först skapar vi en tabell med innehåll.

Skapa tabellen i din fil `create.sql` och verifiera att det fungerar.

```sql title="En tabell för konton."
--
-- Table account
--
DROP TABLE IF EXISTS `account`;
CREATE TABLE `account`
(
    `id` CHAR(4) PRIMARY KEY,
    `name` VARCHAR(8),
    `balance` DECIMAL(4, 2)
);

SHOW TABLES;
```

Kör skriptet minst två gånger för att dubbelkolla att det fungerar att köra flera gånger efter varandra.



## Data i tabellen

Skapa nu en ny fil `insert.sql` där vi placerar kod som gör insert i tabellen så att det finns ett par konton som vi kan flytta mellan.

```sql title="INSERT in i tabellen."
DELETE FROM `account`;

INSERT INTO `account`
VALUES
    ('1111', 'Adam', 10.0),
    ('2222', 'Eva', 7.0)
;

SELECT * FROM `account`;
```

Kontrollera att du kan köra filen `create.sql` följt av `insert.sql`.

Ett sätt du kan testa är att starta terminalklienten mariadb och köra följande kommandon.

```sql title="Att köra SQL-skript i terminalklienten."
$ mariadb mydb
MariaDB [mydb]> source create.sql
MariaDB [mydb]> source insert.sql
```

Det kommer en del utskrifter från kommandona. Om du är osäker om det fungerar så kan du göra SELECT-satser efter de kommandon du är osäker på. Du kan också lägga till `SHOW WARNINGS;` efter vissa satser, för att se om det blir några felutskrifter. 

Bra, då har vi en tabell att utgå ifrån. Adam har 10 bitcoins och Eva har 7.

Det kan se ut så här.

```sql title="En tabell med bitcoin."
MariaDB [mydb]> SELECT * FROM account;
+------+------+---------+
| id   | name | balance |
+------+------+---------+
| 1111 | Adam |   10.00 |
| 2222 | Eva  |    7.00 |
+------+------+---------+
```



## Flytta pengar 

Låt oss säga att Adam och Eva har slagit vad i Melodifestivalen och Adam förlorade och skall skicka 1.5 bitcoins till Eva.

SQL-koden för den flytten ser ut så här. Spara koden i en ny fil `dml.sql`.

```sql title="Flytta 1.5 bitcoin från Adam till Eva."
--
-- Move the money
--
SET @amount = 1.5;
SET @from = '1111';
SET @to   = '2222';

UPDATE `account`
SET
    `balance` = `balance` - @amount
WHERE
    `id` = @from;

UPDATE `account`
SET
    `balance` = `balance` + @amount
WHERE
    `id` = @to;

SELECT * FROM `account`;
```

Du kan köra hela skriptet med `source dml.sql`.

Vi använder variabler för att göra koden tydligare.

I den första satsen tar vi bort pengen från Adams konto. i den andra satsen lägger vi till pengen till Evas konto.

I mellanläget innehåller databasen färre pengar än det egentligen finns. Det är när pengarna lämnat Adams konto men ännu inte fyllts på hos Adams konto. I detta läget är databasen inte konsistent.

Det hjälper inte om vi byter ordning på satserna och skapar ett överskott istället. Databasen är lika mycket ur balans och ej konsistent i båda fallen.

Till vår hjälp kommer transaktionen.



## Flytta med transaktion

Vi lägger flytten av pengarna inom ramen för en transaktion, så att flytten av pengar blir atomär och databasen behåller sin konsistens oavsett vad som händer.

En transaktion inleds med `START TRANSACTION` och avslutas med `COMMIT`. Om man av någon anledning vill avbryta en transaktion så gör man `ROLLBACK` istället för `COMMIT`.

```sql title="Flytta pengar inuti en transaktion."
--
-- Move the money, within a transaction
--
START TRANSACTION;

SET @amount = 1.5;
SET @from = '1111';
SET @to   = '2222';

UPDATE `account`
SET
    `balance` = `balance` - @amount
WHERE
    `id` = @from;

UPDATE `account`
SET
    `balance` = `balance` + @amount
WHERE
    `id` = @to;

COMMIT;

SELECT * FROM `account`;
```

Det är alltså `START TRANSACTION` som påbörjar transaktionen och det är `COMMIT` som avslutar den. Alla skeenden som utförs inom transaktionen är nu atomära.

Om du gör en `ROLLBACK` istället för en `COMMIT` så görs en undo på hela sekvensen som utfördes inom transaktionen. Det är så att COMMIT utför alla ändringar och ROLLBACK tar bort effekten av allt som utförts i transaktionen.

En transaktion avslutas med en COMMIT, eller avbryts med en ROLLBACK.



## Hindra att någon får 0 på kontot

Om vi fortsätter att flytta pengar i en riktning så kommer det att ta slut på ena kontot. Då skall vi inte kunna flytta mer pengar. 

Alltså, om vi vill hindra att det inte kan bli 0 på ett konto så behöver vi en kontroll för detta. En sådan kontroll behöver också vara inom ramen för transaktionen.

Tyvärr har vi ännu inte riktigt möjligheten att utföra en sådan kontroll och få det att fungera i en transaktion. Vi hade velat ha någon form av IF-sats eller liknande, men i ett rent SQL-skript har vi inte den möjligheten.

Vi får helt enkelt avvakta tills vi lärt oss mer konstruktioner för att programmera i databasen.



## Avslutningsvis

Detta var en introduktion till transaktioner och hur man kan omsluta flera frågor inuti en transaktion och får den att utföra samtliga, eller ingen, uppdatering i databasen.

