---
title: "Övning: CSharp med lagrade procedurer" 
description: "Övning för att använda lagrade procedurer med CSharp."
author: mos
revision:
    "2026-02-13": "(A, mos) Första versionen."
sidebar:
    order: 0510
---

import Figure from '@components/CustomFigure.astro';
import YouTube from '@components/YouTube.astro';

{/*
TODO
* 
* 
*/}

I denna övningen skall vi använda oss av programmeringsspråket CSharp och koppla upp oss mot en befintlig databas och utföra en transaktion för att flytta pengar mellan konton. Vi skall göra det inom ramen för en lagrad procedur.

{/*
import cs1 from '@assets/databas/csharp/cs1.png';

<Figure 
    src={cs1}
    caption="Ett C# program som presenterar data från databasen classicmodels."
/>
*/}


## Förutsättningar

Du har jobbat igenom övningen "Övning: Lagrade procedurer i databas" och du har tillgång till databasen "mydb".



## Spara ditt arbete i ditt kursrepo

I ditt kursrepo, skapa följande katalog där du kan spara ditt arbete med denna övning:

```bash title="Skapa CSharp projekt för övningen"
# Gå till ditt kursrepo
cd kmom/05

# Skapa ett project för CSharp
dotnet new console -o BankExample
cd BankExample

# Öppna katalogen i VS Code
code .
```

Öppna filen `Program.cs` och lägg in följande kommentar, överst i filen.

```sql title="Program.cs"
/**
 * Example code on how to work with stored procedure.
 * Course: databas
 * Author: Your Name
 * Date: ÅÅÅÅ-MM-DD
 */
```

Uppdatera med rätt datum och namn. 

Kontrollera att du kan köra programmet.

```bash title="Kör CSharp programmet"
dotnet run
```

Om du ser utskriften `Hello, World!` i terminalen så fungerar allt som det ska.



## Installera paket

Du får gärna återanvända din tidigare kod om du vill. I denna artikeln kommer vi att återanvända delar av koden som skrevs i föregående övningar.

Du kan installera paketen som behövs var för sig, eller så återanvänder du en tidigare projektfil där du redan hade installerat paketen. Isåfall kan du göra restore för att installera de paket som behövs.

```bash title="Använd restore för att isntallera paket utifrån projektfilen."
dotnet restore
```

Om du då har till exempel följade rader i din `BankExample.csproj` så kommer de paketen att installeras.

```xml
  <ItemGroup>
    <PackageReference Include="DotNetEnv" Version="3.1.1" />
    <PackageReference Include="MySqlConnector" Version="2.5.0" />
    <PackageReference Include="Spectre.Console" Version="0.54.0" />
  </ItemGroup>
```

<details>
<summary>Installera paketen för hand.</summary>

Så här kan du installera paketen för hand.

```bash title="Installera paket."
# Stå i katalogen för ditt C# projekt
dotnet add package DotNetEnv
dotnet add package MySqlConnector
dotnet add package Spectre.Console
```

</details>



## Lagrad procedur

Denna övningen förutsätter att du har skapat den lagrade proceduren som heter `move_money()` och som diskuterades i övningen om lagrade proedurer. Den proceduren finns nu lagrad i databasen och vi skall anropa den från vårt CSharp-program.

Innan vi börjar så kan du dubbelkolla att du kan anropa den lagrade proceduren.

```sql title="Provkör den lagrade proceduren i terminalklienten."
MariaDB [mydb]> CALL move_money('1111', '2222', 1.5);
+-------------------+
| v_current_balance |
+-------------------+
|             10.00 |
+-------------------+
1 row in set (0,001 sec)

+------+------+---------+
| id   | name | balance |
+------+------+---------+
| 1111 | Adam |    8.50 |
| 2222 | Eva  |    8.50 |
+------+------+---------+
2 rows in set (0,002 sec)
```

Det verkade som det fungerade, pengar fanns och flyttades mellan konton. Då skall vi lägga in det i ett CSharp-program.



## Main-programmet Program.cs

När jag tittar i det förra exempelprogrammet vi skrev för transaktioner, så ser jag nu att vi egentligen kan återanvända exakt samma main-program.

Det ser ut så här:

```csharp title="Program.cs"
using MySqlConnector;
using DatabaseExample;

// Load the .env file
DotNetEnv.Env.Load();

// Connect to the database
using var connection = await Database.GetConnectionAsync();
Console.WriteLine("Connected to the database!");

// Execute a simple query
Queries query = new Queries(connection);
await query.PrintAccountReport();
await query.MoveMoneyFromAdamToEva();
await query.PrintAccountReport();
```

De tre sista metoderna gör själva flytten av pengar och skriver ut behållningen på kontot.

Den metoden vi ska fokusera på är `MoveMoneyFromAdamToEva()`.



## Anropa en lagrad procedur

Jag börjar med att ta en kopia av metoden `MoveMoneyFromAdamToEva()` och döper den till `MoveMoneyFromAdamToEvaStoredProcedure()`. Nu kan jag ha både min gamla och nya version av koden utan att jag förstör något.

Så här blir koden för att anropa en lagrad procedur.

```csharp title="Anropa den lagrade proceduren move_money()"
using System.Data;

    public async Task MoveMoneyFromAdamToEvaStoredProcedure()
    {
        const decimal amount = 1.5m; // 'm' marks the value as decimal
        const string fromId="1111";
        const string toId="2222";

        // Prepare the command
        using var command = new MySqlCommand("move_money", connection);
        command.CommandType = CommandType.StoredProcedure;

        // Add the parameters, use the name of the parameters from the SQL code
        command.Parameters.AddWithValue("@p_from_account", fromId);
        command.Parameters.AddWithValue("@p_to_account", toId);
        command.Parameters.AddWithValue("@p_amount", amount);

        try
        {
            // Execute the command
            await command.ExecuteNonQueryAsync();
        }
        catch (MySqlException ex)
        {
            Console.WriteLine($"Database error: {ex.Message}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Something went wrong: {ex.Message}");
        }
    }
```

Om vi studerar koden ovan så ser vi i delen med variabler att vi använder typen decimal så att vi får samma datatyp i både CSharp och i databasen.

```csharp
const decimal amount = 1.5m; // 'm' marks the value as decimal
```

Därefter förbereder vi kommandot som en lagrad procedur.

```csharp
// Prepare the command
using var command = new MySqlCommand("move_money", connection);
command.CommandType = CommandType.StoredProcedure;
```

Därefter lägger vi till de parametrar som den lagrade proceduren tar och vi använder de namn på parametrarna som deklareras i den lagrade proceduren.

```csharp
// Add the parameters, use the name of the parameters from the SQL code
command.Parameters.AddWithValue("@p_from_account", fromId);
command.Parameters.AddWithValue("@p_to_account", toId);
command.Parameters.AddWithValue("@p_amount", amount);
```

Nu är det klart för att exekveras. Vi bryr oss inte om några resultset eller returvärden från transaktionen, eller ja, förutom om det kastas något exception som vi väljer att fånga.

```csharp
try
{
    // Execute the command
    await command.ExecuteNonQueryAsync();
}
catch (MySqlException ex)
{
    Console.WriteLine($"Database error: {ex.Message}");
}
catch (Exception ex)
{
    Console.WriteLine($"Something went wrong: {ex.Message}");
}
```

När vi kör programmet så kan det nu se ut så här.

```bash title="Pengar flyttas mellan konton via CSharp och en lagrad procedur."
$ dotnet run
Connected to the database!
┌──────┬──────┬─────────┐
│  Id  │ Name │ Balance │
├──────┼──────┼─────────┤
│ 1111 │ Adam │   10.00 │
│ 2222 │ Eva  │    7.00 │
└──────┴──────┴─────────┘
┌──────┬──────┬─────────┐
│  Id  │ Name │ Balance │
├──────┼──────┼─────────┤
│ 1111 │ Adam │    8.50 │
│ 2222 │ Eva  │    8.50 │
└──────┴──────┴─────────┘
```



## En lagrad procedur som ger ett resultset

Proceduren vi använde ovan gav flera resultset tillbaka, men vi valde att inte använda något av dem. När en lagrad procedur ger resultset tillbaka så behöver man tänka att programmet skall kunna veta vilket resultset som är vilket. I vårt fall med `move_money()` är det kanske inte helt tydligt.

Men, får att visa hur man använder ett resultset från en lagrad procedur så tänkte jag göra en procedur som heter `account_report()` och som gör en rapport för alla konton och deras balans.

Vi har en tidigare implementation i CSharp-kod som gör detta via metoden `PrintAccountReport()` och den ser ut så här.

```csharp title="Aktuell version av att skriva ut behållningen på konton."
    public async Task PrintAccountReport()
    {
        const string sql = @"
            SELECT
                id,
                name,
                balance
            FROM account
            ;";
        var cmd = new MySqlCommand(sql, connection);
        await using var result = await cmd.ExecuteReaderAsync();

        var table = new Table();
        table.AddColumn(new TableColumn("[yellow]Id[/]").Centered());
        table.AddColumn("[yellow]Name[/]");
        table.AddColumn(new TableColumn("[yellow]Balance[/]").RightAligned());

        while (await result.ReadAsync())
        {
            table.AddRow(
                result.GetString("id"),
                result.GetString("name"),
                result.GetDecimal("balance").ToString("N2")
            );
        }

        AnsiConsole.Write(table);
    }
```

Nu tar vi koden ovan och gör den till en ny metod som vi döper till `PrintAccountReportStoredProcedure()`, sedan uppdaterar vi koden till att anropa en lagrad procedure som heter `account_report()`.

```csharp title="Uppdaterad version att skriva ut behållningen på konton."
    public async Task PrintAccountReportStoredProcedure()
    {
        using var cmd = new MySqlCommand("account_report", connection);
        cmd.CommandType = CommandType.StoredProcedure;

        await using var result = await cmd.ExecuteReaderAsync();

        var table = new Table();
        table.AddColumn(new TableColumn("[yellow]Id[/]").Centered());
        table.AddColumn("[yellow]Name[/]");
        table.AddColumn(new TableColumn("[yellow]Balance[/]").RightAligned());

        while (await result.ReadAsync())
        {
            table.AddRow(
                result.GetString("id"),
                result.GetString("name"),
                result.GetDecimal("balance").ToString("N2")
            );
        }

        AnsiConsole.Write(table);
    }
```

Om du studerar koden noga så kan du se att det var endast två rader av koden som ändrades. istället för SQL-koden så skapade vi ett kommando baserat på en lagrad procedur.

```csharp title="Koden för att skapa ett kommando till en lagrad procedur."
        using var cmd = new MySqlCommand("account_report", connection);
        cmd.CommandType = CommandType.StoredProcedure;
```

Visst kan man tycka att koden i CSharp blir lite renare nu när man bara ser namnet på den lagrade proceduren och inte hela SELECT-satsen? Om man tycker det så är det en poäng med att dölja databas-koden bakom ett API i form av lagrade procedurer.

Glöm inte bort att skapa din lagrade procedure `account_report()`.

<details>
<summary>Kod för att skapa den lagrade proceduren `account_report()`</summary>

```sql title="Kod för att skapa en lagrad procedur account_report()"
--
-- Account report
--
DROP PROCEDURE IF EXISTS `account_report`;

DELIMITER ;;

CREATE PROCEDURE `account_report`()
BEGIN
    SELECT
        `id`,
        `name`,
        `balance`
    FROM `account`;
END
;;

DELIMITER ;
```

</details>

Kontroller att din kod nu fungerar på samma sätt som tidigare, men med hjälp av den lagrade proceduren för att skriva ut konto-tabellen.



## Lagrad procedur som returnerar flera resultset

Om din lagrade procedure returnerar två eller flera resultset så skapar du kod som först hanterar det ena resultsetet, därefter hämtar du nästa och hanterar det och så vidare tills alla resultset är hanterade.

Så här kan koden se ut för att göra det.

```csharp title="hantera flera resultset från en lagrad procedur."
// Läs första tabellen
while (await reader.ReadAsync()) { ... }

// Hoppa till nästa
await reader.NextResultAsync();

// Läs andra tabellen
while (await reader.ReadAsync()) { ... }
```



## Lagrad procedur som hanterar OUT parametrar

Låt oss titta på ett exempel där vi använder en OUT parameter för att ta reda på balansen på ett konto efter en flytt av pengar.

Den lagrade proceduren `move_money_get_balance()` vi använder för detta ser ut så här när den används.

```sql title="lagrad procedur med OUT parameter."
MariaDB [mydb]> CALL move_money_get_balance('1111', '2222', 1.5, @balance);
MariaDB [mydb]> SELECT @balance;
+----------+
| @balance |
+----------+
|     5.50 |
+----------+
1 row in set (0,000 sec)
```

Först anropar man den lagrade proceduren och därefter kan man läsa av OUT-parameterns värde.

<details>
<summary>Kod för att skapa den lagrade proceduren move_money_get_balance().</summary>

```sql title="Skapa proceduren move_money_get_balance()."
--
-- Example with OUT
--
DROP PROCEDURE IF EXISTS `move_money_get_balance`;

DELIMITER ;;

CREATE PROCEDURE `move_money_get_balance`(
    p_from_account CHAR(4),
    p_to_account CHAR(4),
    p_amount NUMERIC(4, 2),
    OUT p_balance NUMERIC(4, 2)
)
BEGIN
    CALL move_money(p_from_account, p_to_account, p_amount);

    SELECT `balance` INTO p_balance
    FROM `account`
    WHERE `id` = p_from_account;
END
;;

DELIMITER ;
```

</details>

Det vi behöver göra i CSharp är att deklarera OUT parametern i CSharp, i övrigt så handlar det om att anropa den lagrade proceduren som vanligt.

```csharp title="Kod för att jobba med OUT parametrar."
public async Task MoveMoneyWithBalanceOutput()
{
    using var command = new MySqlCommand("move_money_get_balance", connection);
    command.CommandType = CommandType.StoredProcedure;

    command.Parameters.AddWithValue("@p_from_account", "1111");
    command.Parameters.AddWithValue("@p_to_account", "2222");
    command.Parameters.AddWithValue("@p_amount", 1.5m);

    // Define the OUT parameter
    command.Parameters.Add(new MySqlParameter
    {
        ParameterName = "@p_balance",
        MySqlDbType = MySqlDbType.Decimal,
        Direction = ParameterDirection.Output
    });

    await command.ExecuteNonQueryAsync();

    // Get the value of the OUT param
    decimal currentBalance = (decimal)command.Parameters["@p_balance"].Value!;

    Console.WriteLine($"Överföring klar! Nytt saldo: {newBalance:N2}");
}
```

Studera koden ovan och du ser att vi definerar kommandot för den lagrade proceduren och därefter lägger vi till samtliga IN parametrar och därefter lägger vi till en OUT parameter som deklareras med lite fler värden.

```csharp title="Så här deklarerar du en OUT parameter."
// Define the OUT parameter
command.Parameters.Add(new MySqlParameter
{
    ParameterName = "@p_balance",
    MySqlDbType = MySqlDbType.Decimal,
    Direction = ParameterDirection.Output
});
```

Efter att kommandot är utfört så kan du läsa av värdet på OUT parametern.

```csharp title="Så här läser du av värdet på OUT parametern."
// Get the value of the OUT param
decimal currentBalance = (decimal)command.Parameters["@p_balance"].Value!;
```

Det sista utropstecknet är ett sätt att hantera varningar för NULL-värden och i detta sammanhanget säger det att "jag lovar" att det inte kan komma ett NULL-värde i detta uttrycket. Operatorn `!` kallas i detta sammanhanget för "Null-forgiving operator".



## Avslutningsvis

Vi har sett på flera olika sätt hur man kan jobba med lagrade procedurer i CSharp.
