---
title: "Övning: Lagrade procedurer i databas" 
description: "Övning för att använda lagrade procedurer i en databas."
author: mos
revision:
    "2026-02-13": "(A, mos) Första versionen utifrån en befintlig artikel https://dbwebb.se/kunskap/lagrade-procedurer-i-databas."
sidebar:
    order: 0500
---

import Figure from '@components/CustomFigure.astro';
import YouTube from '@components/YouTube.astro';

{/*
TODO
* 
* 
*/}

Ibland räcker det inte med enbart SQL utan man behöver någon form av ytterligare programmeringsmässig hantering av informationen. För att ta ett exempel, säg att man vill flytta pengar från ett konto till ett annat, men bara om det finns tillräckligt mycket pengar på kontot.

Man kan naturligtvis koda detta i godtyckligt externt programmeringsspråk. Men kan det finnas en möjlighet att koda sådant direkt i databasen?

Här kommer lagrade procedurer och "compound statements" till vår hjälp.

{/*
import cs1 from '@assets/databas/csharp/cs1.png';

<Figure 
    src={cs1}
    caption="Ett C# program som presenterar data från databasen classicmodels."
/>
*/}



## Förutsättningar

Artiklen bygger löst vidare på det exemplet som beskrevs i artikeln "[Transaktioner i databas](/website/laromaterial/ovning/transaktioner/)". Du behöver ha tillgång till den databasen med de tabellerna.

Exemplet visar hur du jobbar med lagrade procedurer i MySQL/MariaDB.



## Spara ditt arbete i ditt kursrepo

I ditt kursrepo, skapa följande katalog där du kan spara ditt arbete med denna övning:

```bash title="Skapa katalog för övningen"
# Gå till ditt kursrepo
cd kmom/05

# Skapa en katalog
mkdir procedure
cd procedure

# Öppna katalogen i VS Code
code .
```

Skapa filen `procedure.sql` och lägg in följande kommentar, överst i filen.

```sql title="procedure.sql"
-- Example code on how to work with stored procedures.
-- Course: databas
-- Author: Your Name
-- Date: ÅÅÅÅ-MM-DD
```

Uppdatera med rätt datum och namn. 



## Databasen mydb som exempel

Vi tar samma exempel vi använde i artikeln "Transaktioner i databas". Adam och Eva skall flytta pengar mellan varandra. SQL-koden för exemplet ser ut så här.

Om du inte har databasen så får du gå till den artikeln och använda SQL-koden som finns i den artikeln för att skapa databasen och tabellen.

<details>
<summary>Facit till att skapa databasen för denna övning</summary>

Du kan spara innehållet nedan i en fil `create.sql`.

```sql title="SQL för att skapa databasen som behövs till övningen."
--
-- Create the database
--
DROP DATABASE IF EXISTS `mydb`;
CREATE DATABASE `mydb`
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_unicode_ci
;

USE `mydb`;

--
-- Table account
--
DROP TABLE IF EXISTS `account`;
CREATE TABLE `account`
(
    `id` CHAR(4) PRIMARY KEY,
    `name` VARCHAR(8),
    `balance` DECIMAL(4, 2)
);

--
-- Insert into table account
--
DELETE FROM `account`;
INSERT INTO `account`
VALUES
    ('1111', 'Adam', 10.0),
    ('2222', 'Eva', 7.0)
;

SELECT * FROM `account`;
```

</details>



## Att skriva små program i databasen

Databasen MariaDB stödjer något de kallar [Compound Statements](https://mariadb.com/kb/en/programmatic-compound-statements/) som är det "programmeringsspråk" som används för att skriva lagrade procedurer och liknande konstruktioner (egen-definierade funktioner och trigger). Compound statements kan liknas med traditionell programmeringskod med variabler och loopar som kan interagera med ren SQL-kod.

Detta ger oss en möjlighet att skriva små program i databasen. Dessa program lagras i databasen, de blir till en del av själva databasen.

Låt oss kika på hur en lagrad procedur kan se ut, skriven med SQL och compound statements.



## Exempel på transaktion

I artikeln om transaktioner så använde vi följande kod för att flytta pengar mellan konton.

```sql title="Flytt av pengar med SQL inom en transaktion."
--
-- Move the money, within a transaction
--
START TRANSACTION;

SET @amount = 1.5;
SET @from = '1111';
SET @to   = '2222';

UPDATE `account` SET `balance` = `balance` - @amount WHERE `id` = @from;
UPDATE `account` SET `balance` = `balance` + @amount WHERE `id` = @to;

COMMIT;
```

Det vi nu vill göra är att uppdatera koden så att den tar hänsyn till att det inte kan bli 0 på ett konto. Om det kan bli det så skall vi göra en ROLLBACK av transaktionen och flytten av pengar skall inte genomföras.

Vi kan dock inte använda en IF-sats i vanlig SQL och därför behöver vi en konstruktion av "compund statement" och det är något vi kan skriva inom ramen för en lagrad procedur.

Låt oss se hur det kan se ut.



## En lagrad procedur för att flytta pengar

Vi kan egentligen bara flytta pengar om det finns några pengar på kontot. Vi behöver kontrollera om Adam har så mycket pengar på kontot som han nu är benägen att flytta till Eva.

Vi gör en lagrad procedur som flyttar pengarna, förutsatt att de finns. Principen blir följande:

1. Starta transaktionen.
1. Kolla om pengar finns på kontot
    1. Läs hur mycket pengar som finns på kontot
    1. Gör en IF-sats för att kolla att det är tillräckligt med pengar
        1. Gör ROLLBACK om det inte finns tillräckligt med pengar
1. Flytta pengarna
1. Allt måste ske inom en och samma transaktion
    1. Gör COMMIT.



### Delimiter 

För att skapa en lagrad procedur så omsluter vi dess kod på följande sätt, med en [`CREATE PROCEDURE`](https://mariadb.com/docs/server/server-usage/stored-routines/stored-procedures/create-procedure).

```sql
--
-- Procedure move_money()
--
DROP PROCEDURE IF EXISTS move_money;

DELIMITER ;;

CREATE PROCEDURE move_money(
    -- Here comes the definition of the parameters
)
    -- Here comes SQL and compund statements
;;

DELIMITER ;
```

Koden ändrar *delimiter* för att koden inuti den lagrade proceduren inte skall krocka med det semikolon som avslutar själva proceduren. Det finns även [beskrivet i manualen "Stored Procedure Overview"](https://mariadb.com/docs/server/server-usage/stored-routines/stored-procedures/stored-procedure-overview) om varför man gör så här.

Det ar viktig att se hur du först gör `DELIMITER ;;` innan du påbörjar skapandet av proceduren, sedan avslutas proceduren med `;;` och därefter går du direkt tillbaka till `DELIMITER ;` (som vanligt).

Se dessa DELIMITER som en naturlig del av skapandet av din procedur.



### Parametrar och body

Proceduren tar tre parametrar som säger från-konto, till-konto och summan som skall flyttas.

Låt oss göra en minimal procedur för att anropa den, som ett litet test.

```sql
DROP PROCEDURE IF EXISTS move_money;

DELIMITER ;;

CREATE PROCEDURE move_money(
    p_from_account CHAR(4),
    p_to_account CHAR(4),
    p_amount NUMERIC(4, 2)
)
BEGIN
    SELECT p_from_account, p_to_account, p_amount;
END
;;

DELIMITER ;
```

Notera att procedurens parameterlista har samma datatyper som vi är vana vid från kolumnerna i tabeller.

Vi väljer att lägga ett `p_` framför varje parameter så att vi på det viset kan ha koll på om det är en parameter.

Du kan nu skapa proceduren med koden ovan, den skall fungera.

Glöm inte DELIMITER, jag kommer inte att visa dem i kommande exempel.



### SHOW CREATE PROCEDURE

Du kan verifiera att proceduren skapades med följande kommandon.

```sql title="Visa hur proceduren är skapad."
SHOW CREATE PROCEDURE move_money \G
```

Det kan se ut så här.

```sql title="Exempel på hur proceduren kan vara skapad."
MariaDB [mydb]> SHOW CREATE PROCEDURE move_money \G
*************************** 1. row ***************************
           Procedure: move_money
            sql_mode: STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE DEFINER=`maria`@`localhost` PROCEDURE `move_money`(
    p_from_account CHAR(4),
    p_to_account CHAR(4),
    p_amount NUMERIC(4, 2)
)
BEGIN
    SELECT p_from_account, p_to_account, p_amount;
END
character_set_client: utf8mb3
collation_connection: utf8mb3_general_ci
  Database Collation: utf8mb4_unicode_ci
```

Du kan se vilket character set och collation som användes och du ser att skaparen är den användare som du är inloggad som.

```sql title="Vem skapade proceduren?"
DEFINER=`maria`@`localhost`
```

Försäkra dig om att du verkligen har "maria" som definer. Annars blir det problem vid rättning.



### Anropa en lagrad procedur

Procedurens body är nu på plats, inom ramen av `BEGIN` och `END`. I detta fallet är det en SELECT-sats som kommer att "skriva ut", eller producera, det resultset som blir resultatet från SELECT-satsen.

Då anropar vi proceduren.

```sql title="Anrop till en lagrad procedur."
CALL move_money('1111', '2222', 1.5);
```

Så här kan det se ut i terminalen.

```sql title="Så här ser det ut i terminalen när anropet sker."
MariaDB [mydb]> CALL move_money('1111', '2222', 1.5);
+----------------+--------------+----------+
| p_from_account | p_to_account | p_amount |
+----------------+--------------+----------+
| 1111           | 2222         |     1.50 |
+----------------+--------------+----------+
1 row in set (0,000 sec)

Query OK, 0 rows affected (0,000 sec)
```

Resultatet blir att parametrarna skrivs ut i SQL-satsen, som en form av resultat från proceduren. En enkel procedur kan alltså vara att samla en eller flera SELECT-satser och skriva ut dem.

Bra, då kan vi skapa och anropa en lagrad procedur, och även skicka parametrar till den. Det är en god start.



### Procedur för move_money

Då plockar vi in koden som flyttar pengarna, in i proceduren. Det kan se ut så här. Det är alltså koden inom BEGIN / END som ändrar sig.

```sql
CREATE PROCEDURE move_money(
    p_from_account CHAR(4),
    p_to_account CHAR(4),
    p_amount NUMERIC(4, 2)
)
BEGIN
    START TRANSACTION;

    UPDATE account SET balance = balance - p_amount WHERE id = p_from_account;
    UPDATE account SET balance = balance + p_amount WHERE id = p_to_account;

    COMMIT;

    SELECT * FROM account;
END
;;
```

Ovan SQL-kod flyttar pengar från ett konto till ett annat, inom ramen för en transaktion.

Nu kan jag anropa proceduren, om och om igen. Om jag kör den tillräckligt många gånger så kommer Eva att bli riktigt rik och Adam motsvarande fattig.

```sql
CALL move_money('1111', '2222', 1.5);
```

Att jag väljer att skriva ut behållningen i slutet med SELECT-satsen är (för tillfället) bara för att det skall vara enklare att utveckla, det blir lite som en `console.log()` eller `echo`. Det är alltså en variant av hur man kan debugga sin lagrade procedur.

Så här långt har vi skapat en lagrad procedur som omsluter en större kodsekvens som jag troligen vill utföra många gånger. Det blir som ett API mot min databas. Om man vill flytta pengar mellan konton så är det rätta sättet att göra det via den lagrade proceduren, inte att skriva egen SQL-kod. Lagrade procedurer kan alltså vara ett sätt att bygga API mot databasen.

Kom ihåg att koden för lagrade procedurer inte nödvändigtvis är kompatibel mellan olika databasmotorer. Det kan vara en nackdel, eller inte.

Provkör din lagrade procedur så att du vet att den fungerar. Anrop atillräckligt många gånger så att det blir minus på Adams konto.

```sql title="Nu är det minus hos Adam."
MariaDB [mydb]> CALL move_money('1111', '2222', 1.5);
+------+------+---------+
| id   | name | balance |
+------+------+---------+
| 1111 | Adam |   -0.50 |
| 2222 | Eva  |   17.50 |
+------+------+---------+
```



## Kolla om pengar finns

Då skall vi se om vi kan uppdatera den lagrade proceduren för att kontrollera att det verkligen finns pengar på kontot, innan flyttan av pengar utförs.

Det första jag vill ha är en lokal variabel som jag tänker fylla med nuvarande balans på kontot. Om balansen inte är tillräcklig så kommer jag att avbryta transaktionen med en ROLLBACK.



### Lokal variabel

Låt oss börja kika på den lokala variabeln `v_current_balance` och hur den får sitt värde. Notera att jag väljer att användaa prefix `v_` för lokala variabler.

```sql
BEGIN
    DECLARE v_current_balance NUMERIC(4, 2);

    START TRANSACTION;

    SELECT balance INTO v_current_balance 
        FROM account 
        WHERE id = p_from_account 
        FOR UPDATE;

    SELECT v_current_balance;

    -- Some code omitted
END
;;
```

Notera att variabeln  får sitt värde inuti transaktionen, all kod, även testet om det finns pengar från kontot, måste dra nytta av transaktionens atomära princip och att transaktioner är isolerade från varandra. Vi måste dock använda `FOR UPDATE` i samband med SELECT-satsen för att signalera att datan används inom ramen för transaktionen tillsammans med en UPDATE sats.

Om man kör den uppdaterade proceduren i sin helhet så kan man se att det är två SELECT som skrivs ut från den.

```sql title="Två utskrifter från proceduren."
MariaDB [mydb]> CALL move_money('1111', '2222', 1.5);
+-------------------+
| v_current_balance |
+-------------------+
|             -3.50 |
+-------------------+
1 row in set (0,000 sec)

+------+------+---------+
| id   | name | balance |
+------+------+---------+
| 1111 | Adam |   -5.00 |
| 2222 | Eva  |   22.00 |
+------+------+---------+
```

Det första som skrivs ut är den nuvarande balansen och den andra är resultatet efter att flytten är utförd.



### IF-sats

Då kan vi skapa en if-sats [`IF.. ELSE.. END IF`](https://mariadb.com/docs/server/reference/sql-statements/programmatic-compound-statements/if), med compound statement, som kontrollerar om nuvarande balansen är tillräcklig för att flytta pengarna.

```sql
BEGIN
    -- Some code omitted

    IF v_current_balance - p_amount < 0 THEN
        ROLLBACK;
        SELECT 'Amount on the account is not enough to make transaction.' AS message;
    ELSE
        UPDATE account SET balance = balance - p_amount WHERE id = p_from_account;
        UPDATE account SET balance = balance + p_amount WHERE id = p_to_account;
        COMMIT;
    END IF;

    SELECT * FROM account;
END
;;
```

Jag valde att omsluta koden i IF-satsen, det finns nämligen ingen `RETURN` i en lagrad procedur, vilket hade varit ett alternativ när man väl förstod att transaktionen inte kunde utföras. Men, om man läser manualen noga så finner man [`LEAVE`](https://mariadb.com/docs/server/reference/sql-statements/programmatic-compound-statements/leave) vilket skulle kunna göra koden för den lagrade proceduren, aningen snyggare genom att undvika ELSE delen. Pröva gärna det på egen hand.

När man provkör den uppdaterade proceduren kan det se ut så här.

```sql title="Misslyckas att flytta pengar."
MariaDB [mydb]> CALL move_money('1111', '2222', 1.5);
+-------------------+
| v_current_balance |
+-------------------+
|             -5.00 |
+-------------------+
1 row in set (0,000 sec)

+----------------------------------------------------------+
| message                                                  |
+----------------------------------------------------------+
| Amount on the account is not enough to make transaction. |
+----------------------------------------------------------+
1 row in set (0,000 sec)

+------+------+---------+
| id   | name | balance |
+------+------+---------+
| 1111 | Adam |   -5.00 |
| 2222 | Eva  |   22.00 |
+------+------+---------+
2 rows in set (0,000 sec)
```

Här ser man att det är negativ balans på kontot och det blir då ROLLBACK i transaktionen. Själva utskrifterna från proceduren är mest för att visualisera vad som händer, så att vi kan följa flödet.


## Compound statement

Ovan är DECLARE och IF-sats är exempel på kod som är ett compound statement. För att se fler konstruktioner som går att använda så har manualen ett stycke om [Programmatic & Compound Statements](https://mariadb.com/docs/server/reference/sql-statements/programmatic-compound-statements).

Du kan läsa om variabler, hur de kan deklareas, sättas med ett hårdkodat värde eller få ett värde från en SQL-sats.

Du kan läsa om loop-konstruktioner, if-satser och case.

Det är helt enkelt ett eget programmeringsspråk, inuti databasen.



## Lokala variabler 

Innan vi går vidare så vill jag visa konceptet med lokala variabler och hur man även kan använda det för att mellanlagra information i ett SQL-skript. Detta handlar alltså inte enbart om compound statements, utan även om hantering av variabler i traditionell SQL-kod.

Man kan sätta värdet på en lokal variabel, inuti ett SQL-skript, och använda det på följande sätt.

```sql
--
-- Define and use local variable
--
SET @answer = 42;
SELECT @answer;
```

Kör man koden ovan så ser det ut så här.

```sql
mysql> SET @answer = 42;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT @answer;
+---------+
| @answer |
+---------+
|      42 |
+---------+
1 row in set (0.00 sec)
```

Man kan också tilldela en variabel ett resultat från en SELECT-fråga.

```sql
--
-- Set local variable from a resultset
--
SET @answer = (SELECT 42);
SELECT @answer;
```

Det kan se ut så här.

```sql
mysql> SET @answer = (SELECT 42);
Query OK, 0 rows affected (0.01 sec)

mysql> SELECT @answer;
+---------+
| @answer |
+---------+
|      42 |
+---------+
1 row in set (0.00 sec)
```

Man kan också köra en `SELECT...INTO` som kan lagra information från flera kolumner in i variabler.

```sql
--
-- Select mutiple into variables
--
SELECT 1, 2 INTO @a, @b;
SELECT @a, @b;
```

Det kan se ut så här när man kör det.

```sql
mysql> SELECT 1, 2 INTO @a, @b;
Query OK, 1 row affected (0.00 sec)

mysql> SELECT @a, @b;
+------+------+
| @a   | @b   |
+------+------+
|    1 |    2 |
+------+------+
1 row in set (0.00 sec)
```

Denna hantering av variabler kallas i manualen för "[User-Defined Variables](https://mariadb.com/docs/server/reference/sql-structure/sql-language-structure/user-defined-variables)".

Du kan använda detta sättet för att hantera variabler även inuti en lagrad procedur, detta sättet och DECLARE är två sätt du kan välja att använda för variabler, antingen i ditt SQL-script eller i ett compund statement.



## IN och UT parametrar

En lagrad procedur kan ta IN, OUT och INOUT parametrar. Det vi använt hittills är IN parametrar. Låt oss se ett exempel på hur det ser ut.

Här är ett exempel på en lagrad procedur `get_money` som tar `IN account` för att kontrollera hur mycket pengar som finns på kontot och det resulterande värdet sätts i parametern `OUT total`. Den som anropar proceduren kan alltså använda värdet på `total` utanför proceduren.

```sql
CREATE PROCEDURE get_money(
    IN p_account CHAR(4),
    OUT p_total NUMERIC(4, 2)
)
BEGIN
    SELECT balance INTO p_total FROM account WHERE id = p_account;
END
;;
```

Proceduren tar två argument, det ena är IN och det andra är OUT.

I SELECT-satsen hämtas ett värde från databasen och lagras i variabeln `p_total`.

Så här kan det se ut när vi anropar proceduren och bifogar en variabel att spara totalen i.

```sql
CALL get_money('1111', @sum);
SELECT @sum;
```

När anropet sker med CALL så bifogas en variabel som efter anropet kan läsas av och användas vidare.

Det kan se ut så här när vi kör anropen ovan.

```sql
mysql> CALL get_money('1111', @sum);
Query OK, 1 row affected (0.00 sec)

mysql> SELECT @sum;
+------+
| @sum |
+------+
| 7.00 |
+------+
1 row in set (0.00 sec)
```

Här ser vi alltså hur en lagrad procedur kan samverka med en variabel.

En lagrad procedur kan även ta ett argument som är INOUT, det betyder både IN och OUT. Proceduren tar värdet som IN parameter och kan sedan uppdatera innehållet i variabeln. Den som anropar proceduren kan sedan använda det uppdaterade värdet.



## SHOW WARNINGS

Ibland kan man se att man får en varning av ett anrop till en lagrad procedur. I följande exempel anger jag ett värde på en variabeln som är utanför variabelens range.

```sql
mysql> CALL edit_account('1337', 'Mega', 4200000);
Query OK, 1 row affected, 1 warning (0.00 sec)
```

För att se vad varningen säger så kan jag läsa av den.

```sql
mysql> SHOW WARNINGS;
+---------+------+---------------------------------------------------+
| Level   | Code | Message                                           |
+---------+------+---------------------------------------------------+
| Warning | 1264 | Out of range value for column 'p_balance' at row 1 |
+---------+------+---------------------------------------------------+
1 row in set (0.00 sec)
```

Det kan vara bra att ha koll på detta, det är en felkälla och ett bra verktyg för felsökning och utveckling.



## SHOW PROCEDURE

När man vill se vilka procedurer som finns i databasen så kan man visa dem. Här visar jag de procedurer som slutar på delsträngen `%money`.

```sql
SHOW PROCEDURE STATUS LIKE '%money';
```

Svaret blir en lista med alla de procedurer som finns och till vilken databas de är kopplade samt vilken användare som skapade dem.

Vill du sedan titta på koden som ligger bakom den lagrade proceduren så frågar du efter den.

```sql
SHOW CREATE PROCEDURE move_money \G;
```

Fram kommer källkoden för proceduren och man kan kontrollera/felsöka att det är "rätt version" som man använder.

Tänk på att du kan använda `ALTER PROCEDURE`, som ett alternativ till `DROP/CREATE`. Det kan vara smidigt, till exempel när man utvecklar och hela tiden skapar om proceduren och testar små ändringar.



## Avslutningsvis

Detta var grunderna i hur du kan jobba med lagrade procedurer som ett sätt att programmera i en databas. Kanske kan detta även vara ett sätt att bygga ett API mot en databas.

